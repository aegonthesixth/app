<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MUN Speech Timer</title>
    <style>
        :root {
            --primary-color: #6750A4;
            --secondary-color: #625B71;
            --background-color: #F8F8FC;
            --text-color: #1C1B1F;
            --accent-color: #03DAC6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        #app {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .tabs {
            display: flex;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px 15px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
        }

        .tab-content {
            display: none;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .timer-display {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
        }

        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .list-container {
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .list-item {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .list-item:last-child {
            border-bottom: none;
        }

        .list-item.selected {
            background-color: var(--primary-color);
            color: white;
        }

        #committee-select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Tab Navigation -->
        <div class="tabs">
            <div class="tab active" data-tab="main">Main Dashboard</div>
            <div class="tab" data-tab="speaking-list">Speaking List</div>
            <div class="tab" data-tab="timers">Timers</div>
        </div>

        <!-- Main Dashboard Tab -->
        <div id="main-tab" class="tab-content active">
            <div class="section-header">
                <h2>Main Dashboard</h2>
            </div>

            <select id="committee-select">
                <option value="UNSC">United Nations Security Council (UNSC)</option>
                <option value="UNODC">UN Office on Drugs and Crime (UNODC)</option>
            </select>

            <div class="section-header">
                <h3>Country List</h3>
                <button id="add-to-list-btn" class="btn btn-primary">Add to Speaking List</button>
            </div>
            <div id="country-list" class="list-container"></div>
        </div>

        <!-- Speaking List Tab -->
        <div id="speaking-list-tab" class="tab-content">
            <div class="section-header">
                <h2>Speaking List</h2>
                <div>
                    <button id="next-speaker-btn" class="btn btn-primary">Next Speaker</button>
                    <button id="skip-speaker-btn" class="btn btn-secondary">Skip Speaker</button>
                </div>
            </div>
            <div id="speaking-list" class="list-container"></div>
        </div>

        <!-- Timers Tab -->
        <div id="timers-tab" class="tab-content">
            <div class="section-header">
                <h2>Timers</h2>
            </div>

            <!-- Session Timer -->
            <div class="timer-section">
                <h3>Session Timer</h3>
                <div id="session-timer" class="timer-display">00:00</div>
                <div class="timer-controls">
                    <button id="session-start-btn" class="btn btn-primary" data-timer="session" data-action="start">Start</button>
                    <button id="session-stop-btn" class="btn btn-secondary" data-timer="session" data-action="stop">Stop</button>
                    <button id="session-reset-btn" class="btn btn-secondary" data-timer="session" data-action="reset">Reset</button>
                </div>
            </div>

            <!-- Caucus Timer -->
            <div class="timer-section">
                <h3>Caucus Timer</h3>
                <div id="caucus-timer" class="timer-display">00:00</div>
                <div class="timer-controls">
                    <button id="caucus-start-btn" class="btn btn-primary" data-timer="caucus" data-action="start">Start</button>
                    <button id="caucus-stop-btn" class="btn btn-secondary" data-timer="caucus" data-action="stop">Stop</button>
                    <button id="caucus-reset-btn" class="btn btn-secondary" data-timer="caucus" data-action="reset">Reset</button>
                </div>
            </div>

            <!-- Speech Timer -->
            <div class="timer-section">
                <h3>Speech Timer</h3>
                <div id="speech-timer" class="timer-display">00:00</div>
                <div class="timer-controls">
                    <button id="speech-start-btn" class="btn btn-primary" data-timer="speech" data-action="start">Start</button>
                    <button id="speech-stop-btn" class="btn btn-secondary" data-timer="speech" data-action="stop">Stop</button>
                    <button id="speech-reset-btn" class="btn btn-secondary" data-timer="speech" data-action="reset">Reset</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // MUN Speech Timer - Core Application Structure
        class MUNSpeechTimerApp {
            constructor() {
                // Application-wide configuration
                this.config = {
                    version: '1.0.0',
                    theme: 'default',
                    language: 'en',
                    debug: true  // Enable debug mode for more logging
                };

                // Comprehensive state management
                this.state = {
                    // Committee management
                    currentCommittee: 'UNSC',
                    committees: {
                        "UNSC": ["United States", "China", "Russian Federation", "United Kingdom", "France", 
                            "Albania", "Brazil", "Gabon", "Ghana", "India", "Ireland", "Kenya", "Mexico", 
                            "Norway", "United Arab Emirates"],
                        "UNODC": ["Germany", "Canada", "Mexico", "Brazil", "Japan", "France", "United Kingdom", 
                            "Russian Federation", "China", "United States", "Italy", "Spain", "Netherlands"]
                    },

                    // Speaking list management
                    speakingList: [],
                    currentSpeaker: null,
                    speakerHistory: [],

                    // Timer management
                    timers: {
                        session: {
                            running: false,
                            startTime: null,
                            elapsedTime: 0
                        },
                        caucus: {
                            running: false,
                            startTime: null,
                            elapsedTime: 0
                        },
                        speech: {
                            running: false,
                            startTime: null,
                            elapsedTime: 0
                        }
                    },

                    // UI state
                    ui: {
                        activeTab: 'main',
                        selectedCountry: null
                    }
                };

                // Logging system
                this.logger = {
                    logs: [],
                    log(message, type = 'info') {
                        const logEntry = {
                            timestamp: new Date(),
                            message,
                            type
                        };
                        this.logs.push(logEntry);
                        
                        // Console logging for debug mode
                        if (this.config.debug) {
                            console.log(`[${type.toUpperCase()}]`, message);
                        }
                    },
                    error(message) {
                        this.log(message, 'error');
                        console.error(message);
                    }
                };

                // Initialize the application
                this.initializeApplication();
            }

            // Application initialization method
            initializeApplication() {
                try {
                    this.logger.log('Initializing MUN Speech Timer Application');
                    
                    // Setup event listeners
                    this.setupEventListeners();

                    // Log successful initialization
                    this.logger.log('Application initialized successfully');
                } catch (error) {
                    this.logger.error(`Initialization failed: ${error.message}`);
                }
            }

            // Setup global event listeners
            setupEventListeners() {
                // Placeholder for event listener setup
                this.logger.log('Setting up global event listeners');
            }

            // Utility method for time formatting
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Speaking List Manager
        class SpeakingListManager {
            constructor(app) {
                this.app = app;
            }

            // Add a speaker to the speaking list
            addToSpeakingList(speaker) {
                // Validate input
                if (!speaker || typeof speaker !== 'string') {
                    this.app.logger.error('Invalid speaker name');
                    return false;
                }

                // Check if speaker is already in the list
                if (!this.app.state.speakingList.includes(speaker)) {
                    // Add speaker to the list
                    this.app.state.speakingList.push(speaker);
                    
                    // Log the addition
                    this.app.logger.log(`Added ${speaker} to speaking list`);

                    // Trigger UI update if needed
                    this.updateUI();

                    return true;
                } else {
                    // Speaker already in the list
                    this.app.logger.log(`${speaker} is already in the speaking list`);
                    return false;
                }
            }

            // Move to the next speaker
            nextSpeaker() {
                // Check if there are speakers in the list
                if (this.app.state.speakingList.length > 0) {
                    // Remove the first speaker from the list
                    const currentSpeaker = this.app.state.speakingList.shift();
                    
                    // Update current speaker
                    this.app.state.currentSpeaker = currentSpeaker;

                    // Add to speaker history
                    if (!this.app.state.speakerHistory) {
                        this.app.state.speakerHistory = [];
                    }
                    this.app.state.speakerHistory.push(currentSpeaker);

                    // Log the speaker change
                    this.app.logger.log(`Next speaker: ${currentSpeaker}`);

                    // Trigger UI update
                    this.updateUI();

                    return currentSpeaker;
                } else {
                    // No speakers in the list
                    this.app.state.currentSpeaker = null;
                    this.app.logger.log('No more speakers in the list');
                    return null;
                }
            }

            // Skip the current speaker
            skipCurrentSpeaker() {
                // Check if there's a current speaker
                if (this.app.state.currentSpeaker) {
                    // Add current speaker back to the end of the list
                    this.app.state.speakingList.push(this.app.state.currentSpeaker);
                    
                    // Log the skip
                    this.app.logger.log(`Skipped speaker: ${this.app.state.currentSpeaker}`);

                    // Move to next speaker
                    this.nextSpeaker();
                }
            }

            // Clear the entire speaking list
            clearSpeakingList() {
                // Reset speaking list and current speaker
                this.app.state.speakingList = [];
                this.app.state.currentSpeaker = null;
                
                // Log the action
                this.app.logger.log('Speaking list cleared');

                // Trigger UI update
                this.updateUI();
            }

            // Get current speaking list
            getSpeakingList() {
                return [...this.app.state.speakingList];
            }

            // Update UI (placeholder method to be implemented later)
            updateUI() {
                // This will be connected to the UI manager in a later stage
                console.log('Speaking List Updated:', this.app.state.speakingList);
            }
        }

        // Timer Management System
        class TimerManager {
            constructor(app) {
                this.app = app;
                
                // Timer types to manage
                this.timerTypes = ['session', 'caucus', 'speech'];
            }

            // Start a specific timer
            startTimer(timerType) {
                // Validate timer type
                if (!this.timerTypes.includes(timerType)) {
                    this.app.logger.error(`Invalid timer type: ${timerType}`);
                    return false;
                }

                // Get the specific timer from state
                const timer = this.app.state.timers[timerType];

                // Check if timer is already running
                if (timer.running) {
                    this.app.logger.log(`${// Set start time and mark as running
            timer.startTime = Date.now();
            timer.running = true;

            // Log the timer start
            this.app.logger.log(`${timerType} timer started`);

            // Trigger timer update mechanism
            this.startTimerUpdate(timerType);

            return true;
        }

        // Stop a specific timer
        stopTimer(timerType) {
            // Validate timer type
            if (!this.timerTypes.includes(timerType)) {
                this.app.logger.error(`Invalid timer type: ${timerType}`);
                return false;
            }

            // Get the specific timer from state
            const timer = this.app.state.timers[timerType];

            // Check if timer is running
            if (!timer.running) {
                this.app.logger.log(`${timerType} timer is not running`);
                return false;
            }

            // Calculate elapsed time
            const currentTime = Date.now();
            timer.elapsedTime += (currentTime - timer.startTime);
            
            // Stop the timer
            timer.running = false;
            timer.startTime = null;

            // Log the timer stop
            this.app.logger.log(`${timerType} timer stopped. Total elapsed time: ${this.formatElapsedTime(timer.elapsedTime)}`);

            // Stop timer update mechanism
            this.stopTimerUpdate(timerType);

            return true;
        }

        // Reset a specific timer
        resetTimer(timerType) {
            // Validate timer type
            if (!this.timerTypes.includes(timerType)) {
                this.app.logger.error(`Invalid timer type: ${timerType}`);
                return false;
            }

            // Get the specific timer from state
            const timer = this.app.state.timers[timerType];

            // Stop the timer if it's running
            if (timer.running) {
                this.stopTimer(timerType);
            }

            // Reset timer properties
            timer.elapsedTime = 0;
            timer.startTime = null;
            timer.running = false;

            // Log the timer reset
            this.app.logger.log(`${timerType} timer reset`);

            return true;
        }

        // Start timer update mechanism
        startTimerUpdate(timerType) {
            // Create a timer update interval
            this[`${timerType}TimerInterval`] = setInterval(() => {
                this.updateTimerDisplay(timerType);
            }, 1000);
        }

        // Stop timer update mechanism
        stopTimerUpdate(timerType) {
            // Clear the specific timer interval
            if (this[`${timerType}TimerInterval`]) {
                clearInterval(this[`${timerType}TimerInterval`]);
                this[`${timerType}TimerInterval`] = null;
            }
        }

        // Update timer display
        updateTimerDisplay(timerType) {
            const timer = this.app.state.timers[timerType];
            
            if (timer.running) {
                // Calculate current elapsed time
                const currentTime = Date.now();
                const totalElapsedTime = timer.elapsedTime + (currentTime - timer.startTime);
                
                // Convert to seconds
                const seconds = Math.floor(totalElapsedTime / 1000);
                
                // Format and display the time
                const formattedTime = this.app.formatTime(seconds);
                
                // In a real implementation, this would update the UI
                console.log(`${timerType.toUpperCase()} Timer: ${formattedTime}`);
            }
        }

        // Format elapsed time
        formatElapsedTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds}s`;
        }

        // Get current timer status
        getTimerStatus(timerType) {
            // Validate timer type
            if (!this.timerTypes.includes(timerType)) {
                this.app.logger.error(`Invalid timer type: ${timerType}`);
                return null;
            }

            const timer = this.app.state.timers[timerType];
            return {
                running: timer.running,
                elapsedTime: this.formatElapsedTime(timer.elapsedTime)
            };
        }
    }

    // UI Management System
    class UIManager {
        constructor(app) {
            this.app = app;
            
            // DOM Element References
            this.elements = {
                // Tabs
                tabs: {
                    main: document.querySelector('.tab[data-tab="main"]'),
                    speakingList: document.querySelector('.tab[data-tab="speaking-list"]'),
                    timers: document.querySelector('.tab[data-tab="timers"]')
                },
                // Tab Contents
                tabContents: {
                    main: document.getElementById('main-tab'),
                    speakingList: document.getElementById('speaking-list-tab'),
                    timers: document.getElementById('timers-tab')
                },
                // Committee Select
                committeeSelect: document.getElementById('committee-select'),
                
                // Country List
                countryList: document.getElementById('country-list'),
                addToListBtn: document.getElementById('add-to-list-btn'),
                
                // Speaking List
                speakingList: document.getElementById('speaking-list'),
                nextSpeakerBtn: document.getElementById('next-speaker-btn'),
                skipSpeakerBtn: document.getElementById('skip-speaker-btn'),
                
                // Timers
                timers: {
                    session: {
                        display: document.getElementById('session-timer'),
                        startBtn: document.getElementById('session-start-btn'),
                        stopBtn: document.getElementById('session-stop-btn'),
                        resetBtn: document.getElementById('session-reset-btn')
                    },
                    caucus: {
                        display: document.getElementById('caucus-timer'),
                        startBtn: document.getElementById('caucus-start-btn'),
                        stopBtn: document.getElementById('caucus-stop-btn'),
                        resetBtn: document.getElementById('caucus-reset-btn')
                    },
                    speech: {
                        display: document.getElementById('speech-timer'),
                        startBtn: document.getElementById('speech-start-btn'),
                        stopBtn: document.getElementById('speech-stop-btn'),
                        resetBtn: document.getElementById('speech-reset-btn')
                    }
                }
            };

            // Initialize UI
            this.initializeEventListeners();
            this.updateCountryList();
        }

        // Setup Event Listeners
        initializeEventListeners() {
            // Tab Switching
            Object.values(this.elements.tabs).forEach(tab => {
                tab.addEventListener('click', () => this.switchTab(tab.getAttribute('data-tab')));
            });

            // Committee Selection
            this.elements.committeeSelect.addEventListener('change', () => this.onCommitteeChange());

            // Country List
            this.elements.countryList.addEventListener('click', (event) => this.onCountryListClick(event));
            this.elements.addToListBtn.addEventListener('click', () => this.addSelectedCountryToSpeakingList());

            // Speaking List
            this.elements.nextSpeakerBtn.addEventListener('click', () => this.moveToNextSpeaker());
            this.elements.skipSpeakerBtn.addEventListener('click', () => this.skipCurrentSpeaker());

            // Timer Buttons
            this.setupTimerEventListeners();
        }

        // Switch Active Tab
        switchTab(tabName) {
            // Remove active class from all tabs and tab contents
            Object.values(this.elements.tabs).forEach(tab => 
                tab.classList.remove('active'));
            Object.values(this.elements.tabContents).forEach(content => 
                content.classList.remove('active'));

            // Add active class to selected tab and content
            this.elements.tabs[tabName].classList.add('active');
            this.elements.tabContents[tabName].classList.add('active');
        }

        // Update Country List based on Selected Committee
        updateCountryList() {
            const currentCommittee = this.app.state.currentCommittee;
            const countries = this.app.state.committees[currentCommittee] || [];

            // Clear existing list
            this.elements.countryList.innerHTML = '';

            // Populate country list
            countries.forEach(country => {
                const countryElement = document.createElement('div');
                countryElement.classList.add('list-item');
                countryElement.textContent = country;
                this.elements.countryList.appendChild(countryElement);
            });
        }

        // Handle Committee Change
        onCommitteeChange() {
            // Update current committee in app state
            const selectedCommittee = this.elements.committeeSelect.value;
            this.app.state.currentCommittee = selectedCommittee;
            
            // Update country list
            this.updateCountryList();
        }

        // Handle Country List Click
        onCountryListClick(event) {
            if (event.target.classList.contains('list-item')) {
                // Remove selection from all items
                this.elements.countryList.querySelectorAll('.list-item')
                    .forEach(item => item.classList.remove('selected'));
                
                // Add selection to clicked item
                event.target.classList.add('selected');
            }
        }

        // Add Selected Country to Speaking List
        addSelectedCountryToSpeakingList() {
            const selectedCountry = this.elements.countryList
                .querySelector('.list-item.selected');
            
            if (selectedCountry) {
                const countryName = selectedCountry.textContent;
                this.app.speakingListManager().addToSpeakingList(countryName);
                this.updateSpeakingList();
            } else {
                alert('Please select a country first');
            }
        }

        // Update Speaking List Display
        updateSpeakingList() {
            const speakingList = this.app.speakingListManager().getSpeakingList();
            
            // Clear existing list
            this.elements.speakingList.innerHTML = '';

            // Populate speaking list
            speakingList.forEach(country => {
                const listItem = document.createElement('div');
                listItem.classList.add('list-item');
                listItem.textContent = country;
                this.elements.speakingList.appendChild(listItem);
            });
        }

        // Move to Next Speaker
        moveToNextSpeaker() {
            this.app.speakingListManager().nextSpeaker();
            this.updateSpeakingList();
        }

        // Skip Current Speaker
        skipCurrentSpeaker() {
            this.app.speakingListManager().skipCurrentSpeaker();
            this.updateSpeakingList();
        }

        // Setup Timer Event Listeners
        setupTimerEventListeners() {
            // Iterate through timer types
            ['session', 'caucus', 'speech'].forEach(timerType => {
                const timerControls = this.elements.timers[timerType];

                // Start Button
                timerControls.startBtn.addEventListener('click', () => {
                    this.app.timerManager().startTimer(timerType);
                });

                // Stop Button
                timerControls.stopBtn.addEventListener('click', () => {
                    this.app.timerManager().stopTimer(timerType);
                });

                // Reset Button
                timerControls.resetBtn.addEventListener('click', () => {
                    this.app.timerManager().resetTimer(timerType);
                });
            });
        }

        // Update Timer Display (to be called periodically)
        updateTimerDisplay(timerType) {
            const timerStatus = this.app.timerManager().getTimerStatus(timerType);
            
            if (timerStatus) {
                const timerDisplay = this.elements.timers[timerType].display;
                
                // Update display with current time
                timerDisplay.textContent = timerStatus.running 
                    ? timerStatus.elapsedTime 
                    : '00:00';
            }
        }
    }

    // MUN Speech Timer - Comprehensive Integration Script

    // Extend the main MUNSpeechTimerApp with additional methods and integrations
    MUNSpeechTimerApp.prototype.initialize = function() {
        // Initialize all core systems
        this.initializeManagers();
        this.setupGlobalEventListeners();
        this.restoreApplicationState();
    };

    MUNSpeechTimerApp.prototype.initializeManagers = function() {
        // Initialize core managers
        this.speakingListManager = new SpeakingListManager(this);
        this.timerManager = new TimerManager(this);
        this.uiManager = new UIManager(this);
    };

    MUNSpeechTimerApp.prototype.setupGlobalEventListeners = function() {
        // Save state before page unload
        window.addEventListener('beforeunload', () => {
            this.saveApplicationState();
        });

        // Optional: Handle potential errors globally
        window.addEventListener('error', (event) => {
            this.logger.error(`Unhandled error: ${event.message}`);
        });
    };

    MUNSpeechTimerApp.prototype.saveApplicationState = function() {
        try {
            // Serialize and save the current application state
            const stateToSave = JSON.stringify({
                currentCommittee: this.state.currentCommittee,
                speakingList: this.state.speakingList,
                speakerHistory: this.state.speakerHistory,
                timers: this.state.timers
            });

            localStorage.setItem('munAppState', stateToSave);
            this.logger.log('Application state saved successfully');
        } catch (error) {
            this.logger.error(`Failed to save application state: ${error.message}`);
        }
    };

    MUNSpeechTimerApp.prototype.restoreApplicationState = function() {
        try {
            const savedState = localStorage.getItem('munAppState');
            
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                
                // Restore specific state components
                if (parsedState.currentCommittee) {
                    this.state.currentCommittee = parsedState.currentCommittee;
                }

                if (parsedState.speakingList) {
                    this.state.speakingList = parsedState.speakingList;
                }

                if (parsedState.speakerHistory) {
                    this.state.speakerHistory = parsedState.speakerHistory;
                }

                if (parsedState.timers) {
                    this.state.timers = parsedState.timers;
                }

                this.logger.log('Application state restored successfully');
            }
        } catch (error) {
            this.logger.error(`Failed to restore application state: ${error.message}`);
        }
    };

    // Enhanced initialization process
    document.addEventListener('DOMContentLoaded', () => {
        // Create the main application instance
        const munApp = new MUNSpeechTimerApp();

        // Initialize the application
        munApp.initialize();

        // Debug logging
        console.log('MUN Speech Timer Initialized');
    });
</script>
</body>
</html>
</parameter>
<parameter name="content">OK</parameter>
</invoke>
