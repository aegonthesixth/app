// MUN Speech Timer - Core Application Structure
class MUNSpeechTimerApp {
    constructor() {
        // Application-wide configuration and state
        this.config = {
            version: '1.0.0',
            theme: 'modern',
            language: 'en',
            debug: false
        };

        // Comprehensive state management
        this.state = {
            // Committee management
            currentCommittee: 'UNSC',
            committees: {
                "UNSC": ["United States", "China", "Russian Federation", "United Kingdom", "France", 
                    "Albania", "Brazil", "Gabon", "Ghana", "India", "Ireland", "Kenya", "Mexico", 
                    "Norway", "United Arab Emirates"],
                "UNODC": ["Germany", "Canada", "Mexico", "Brazil", "Japan", "France", "United Kingdom", 
                    "Russian Federation", "China", "United States", "Italy", "Spain", "Netherlands"],
                // More committees as in original implementation
            },

            // Speaking list and current speaker management
            speakingList: [],
            currentSpeaker: null,
            speakerHistory: [],

            // Timer management
            timers: {
                session: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                },
                caucus: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                },
                speech: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                }
            },

            // Delegate and attendance tracking
            delegateData: {},
            attendanceData: {},
            attendanceDates: [],

            // Messaging system
            messaging: {
                authenticatedUser: null,
                messages: [],
                conversations: {}
            },

            // UI and interaction states
            ui: {
                isCountryListLocked: false,
                selectedCountry: null,
                activeTab: 'main'
            }
        };

        // Logging and error tracking
        this.logger = {
            logs: [],
            log(message, type = 'info') {
                const logEntry = {
                    timestamp: new Date(),
                    message,
                    type
                };
                this.logs.push(logEntry);
                
                if (this.config.debug) {
                    console.log(`[${type.toUpperCase()}]`, message);
                }
            },
            error(message) {
                this.log(message, 'error');
            }
        };

        // Authentication management
        this.authManager = {
            githubClientId: null,
            githubClientSecret: null,
            token: null,
            
            initiateGitHubAuth() {
                // Placeholder for GitHub OAuth flow
                throw new Error('GitHub Authentication not implemented');
            },
            
            verifyToken() {
                // Token verification logic
                return this.token !== null;
            }
        };

        // Performance and analytics tracking
        this.analytics = {
            sessionStartTime: null,
            performanceMetrics: {
                renderTimes: [],
                eventProcessingTimes: []
            },
            
            startSession() {
                this.sessionStartTime = Date.now();
            },
            
            trackRenderPerformance(renderFunction) {
                const start = performance.now();
                renderFunction();
                const end = performance.now();
                this.performanceMetrics.renderTimes.push(end - start);
            }
        };

        // Initialize core systems
        this.initializeApplication();
    }

    // Comprehensive application initialization
    initializeApplication() {
        try {
            this.loadPersistedState();
            this.setupEventListeners();
            this.initializeUI();
            this.analytics.startSession();
            this.logger.log('Application initialized successfully');
        } catch (error) {
            this.logger.error(`Initialization failed: ${error.message}`);
            this.displayErrorToUser(error);
        }
    }

    // Load persisted state from local storage
    loadPersistedState() {
        try {
            const savedState = localStorage.getItem('munAppState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                // Merge saved state with default state
                this.state = {
                    ...this.state,
                    ...parsedState
                };
                this.logger.log('Persisted state loaded successfully');
            }
        } catch (error) {
            this.logger.error(`Failed to load persisted state: ${error.message}`);
        }
    }

    // Save current application state
    saveApplicationState() {
        try {
            localStorage.setItem('munAppState', JSON.stringify(this.state));
            this.logger.log('Application state saved');
        } catch (error) {
            this.logger.error(`Failed to save state: ${error.message}`);
        }
    }

    // Setup global event listeners
    setupEventListeners() {
        // Placeholder for comprehensive event listener setup
        // Will be expanded in subsequent implementations
        window.addEventListener('beforeunload', () => {
            this.saveApplicationState();
        });
    }

    // Initialize User Interface
    initializeUI() {
        // Basic UI initialization
        // Detailed UI setup will be in subsequent implementations
        this.updateCountryList();
        this.resetAllTimers();
    }

    // Update country list based on selected committee
    updateCountryList() {
        const currentCommittee = this.state.currentCommittee;
        const countries = this.state.committees[currentCommittee] || [];
        
        // Placeholder for actual DOM manipulation
        this.logger.log(`Updated country list for ${currentCommittee}`);
    }

    // Reset all timers
    resetAllTimers() {
        Object.keys(this.state.timers).forEach(timerType => {
            this.state.timers[timerType] = {
                running: false,
                startTime: null,
                elapsedTime: 0
            };
        });
    }

    // Display error to user (placeholder)
    displayErrorToUser(error) {
        console.error('Application Error:', error);
        // In a real implementation, this would show a user-friendly error modal
    }

    // Utility method for time formatting
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
}

// Application Initialization
document.addEventListener('DOMContentLoaded', () => {
    window.munApp = new MUNSpeechTimerApp();
});
// MUN Speech Timer - Core Application Structure
class MUNSpeechTimerApp {
    constructor() {
        // Application-wide configuration and state
        this.config = {
            version: '1.0.0',
            theme: 'modern',
            language: 'en',
            debug: false
        };

        // Comprehensive state management
        this.state = {
            // Committee management
            currentCommittee: 'UNSC',
            committees: {
                "UNSC": ["United States", "China", "Russian Federation", "United Kingdom", "France", 
                    "Albania", "Brazil", "Gabon", "Ghana", "India", "Ireland", "Kenya", "Mexico", 
                    "Norway", "United Arab Emirates"],
                "UNODC": ["Germany", "Canada", "Mexico", "Brazil", "Japan", "France", "United Kingdom", 
                    "Russian Federation", "China", "United States", "Italy", "Spain", "Netherlands"],
                // More committees as in original implementation
            },

            // Speaking list and current speaker management
            speakingList: [],
            currentSpeaker: null,
            speakerHistory: [],

            // Timer management
            timers: {
                session: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                },
                caucus: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                },
                speech: {
                    running: false,
                    startTime: null,
                    elapsedTime: 0
                }
            },

            // Delegate and attendance tracking
            delegateData: {},
            attendanceData: {},
            attendanceDates: [],

            // Messaging system
            messaging: {
                authenticatedUser: null,
                messages: [],
                conversations: {}
            },

            // UI and interaction states
            ui: {
                isCountryListLocked: false,
                selectedCountry: null,
                activeTab: 'main'
            }
        };

        // Logging and error tracking
        this.logger = {
            logs: [],
            log(message, type = 'info') {
                const logEntry = {
                    timestamp: new Date(),
                    message,
                    type
                };
                this.logs.push(logEntry);
                
                if (this.config.debug) {
                    console.log(`[${type.toUpperCase()}]`, message);
                }
            },
            error(message) {
                this.log(message, 'error');
            }
        };

        // Authentication management
        this.authManager = {
            githubClientId: null,
            githubClientSecret: null,
            token: null,
            
            initiateGitHubAuth() {
                // Placeholder for GitHub OAuth flow
                throw new Error('GitHub Authentication not implemented');
            },
            
            verifyToken() {
                // Token verification logic
                return this.token !== null;
            }
        };

        // Performance and analytics tracking
        this.analytics = {
            sessionStartTime: null,
            performanceMetrics: {
                renderTimes: [],
                eventProcessingTimes: []
            },
            
            startSession() {
                this.sessionStartTime = Date.now();
            },
            
            trackRenderPerformance(renderFunction) {
                const start = performance.now();
                renderFunction();
                const end = performance.now();
                this.performanceMetrics.renderTimes.push(end - start);
            }
        };

        // Initialize core systems
        this.initializeApplication();
    }

    // Comprehensive application initialization
    initializeApplication() {
        try {
            this.loadPersistedState();
            this.setupEventListeners();
            this.initializeUI();
            this.analytics.startSession();
            this.logger.log('Application initialized successfully');
        } catch (error) {
            this.logger.error(`Initialization failed: ${error.message}`);
            this.displayErrorToUser(error);
        }
    }

    // Load persisted state from local storage
    loadPersistedState() {
        try {
            const savedState = localStorage.getItem('munAppState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                // Merge saved state with default state
                this.state = {
                    ...this.state,
                    ...parsedState
                };
                this.logger.log('Persisted state loaded successfully');
            }
        } catch (error) {
            this.logger.error(`Failed to load persisted state: ${error.message}`);
        }
    }

    // Save current application state
    saveApplicationState() {
        try {
            localStorage.setItem('munAppState', JSON.stringify(this.state));
            this.logger.log('Application state saved');
        } catch (error) {
            this.logger.error(`Failed to save state: ${error.message}`);
        }
    }

    // Setup global event listeners
    setupEventListeners() {
        // Placeholder for comprehensive event listener setup
        // Will be expanded in subsequent implementations
        window.addEventListener('beforeunload', () => {
            this.saveApplicationState();
        });
    }

    // Initialize User Interface
    initializeUI() {
        // Basic UI initialization
        // Detailed UI setup will be in subsequent implementations
        this.updateCountryList();
        this.resetAllTimers();
    }

    // Update country list based on selected committee
    updateCountryList() {
        const currentCommittee = this.state.currentCommittee;
        const countries = this.state.committees[currentCommittee] || [];
        
        // Placeholder for actual DOM manipulation
        this.logger.log(`Updated country list for ${currentCommittee}`);
    }

    // Reset all timers
    resetAllTimers() {
        Object.keys(this.state.timers).forEach(timerType => {
            this.state.timers[timerType] = {
                running: false,
                startTime: null,
                elapsedTime: 0
            };
        });
    }

    // Display error to user (placeholder)
    displayErrorToUser(error) {
        console.error('Application Error:', error);
        // In a real implementation, this would show a user-friendly error modal
    }

    // Utility method for time formatting
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
}

// Application Initialization
document.addEventListener('DOMContentLoaded', () => {
    window.munApp = new MUNSpeechTimerApp();
});
// Messaging and Authentication System
lass AuthenticationManager {
    constructor(app) {
        this.app = app;
        
        // GitHub OAuth Configuration
        this.githubConfig = {
            // Replace with your actual GitHub OAuth App credentials
            clientId: 'YOUR_GITHUB_CLIENT_ID', 
            clientSecret: 'YOUR_GITHUB_CLIENT_SECRET',
            redirectUri: window.location.origin + '/callback',
            scopes: ['user:email']
        };
    }

    // Updated Authentication Flow
    initiateGitHubAuth() {
        // Generate a random state to prevent CSRF attacks
        const state = this.generateRandomState();
        
        // Store state in localStorage for verification
        localStorage.setItem('github_oauth_state', state);
        
        // Construct GitHub OAuth URL
        const authUrl = `https://github.com/login/oauth/authorize?` +
            `client_id=${this.githubConfig.clientId}` +
            `&redirect_uri=${encodeURIComponent(this.githubConfig.redirectUri)}` +
            `&scope=${this.githubConfig.scopes.join(' ')}` +
            `&state=${state}`;
        
        // Redirect to GitHub authentication
        window.location.href = authUrl;
    }

    // Handle OAuth Callback
    async handleOAuthCallback(code, state) {
        try {
            // Verify state to prevent CSRF
            const storedState = localStorage.getItem('github_oauth_state');
            if (state !== storedState) {
                throw new Error('Invalid state parameter');
            }
            
            // Remove stored state
            localStorage.removeItem('github_oauth_state');

            // Exchange code for access token (this would typically be done server-side)
            const tokenResponse = await this.exchangeCodeForToken(code);

            // Fetch user information
            const userInfo = await this.fetchUserInfo(tokenResponse.access_token);

            // Update application state
            this.app.state.messaging.authenticatedUser = {
                username: userInfo.login,
                name: userInfo.name || userInfo.login,
                email: userInfo.email,
                avatarUrl: userInfo.avatar_url
            };

            // Store tokens securely
            this.storeTokens(tokenResponse);

            // Log successful authentication
            this.app.logger.log(`Authenticated as ${userInfo.login}`);

            // Trigger UI update
            this.onSuccessfulAuthentication();

            return true;
        } catch (error) {
            this.app.logger.error(`Authentication failed: ${error.message}`);
            this.handleAuthenticationError(error);
            return false;
        }
    }

    // Simulated token exchange (in a real app, this would be a server-side call)
    async exchangeCodeForToken(code) {
        // Simulate token exchange 
        return {
            access_token: `github_token_${code}`,
            token_type: 'bearer',
            scope: this.githubConfig.scopes.join(' ')
        };
    }

    // Add a method to check for existing authentication
    checkExistingAuthentication() {
        const storedToken = localStorage.getItem('github_access_token');
        return !!storedToken;
    }
}


class MessagingSystem {
    constructor(app) {
        this.app = app;
        this.conversations = new Map();
    }

    // Send a message
    sendMessage(recipient, content) {
        // Validate inputs
        if (!this.app.state.messaging.authenticatedUser) {
            throw new Error('User not authenticated');
        }

        if (!recipient || !content) {
            throw new Error('Recipient and content are required');
        }

        // Create message object
        const message = {
            id: this.generateMessageId(),
            sender: this.app.state.messaging.authenticatedUser.username,
            recipient: recipient,
            content: content,
            timestamp: Date.now(),
            read: false
        };

        // Store message in conversations
        if (!this.conversations.has(recipient)) {
            this.conversations.set(recipient, []);
        }
        this.conversations.get(recipient).push(message);

        // Update application state
        this.app.state.messaging.messages.push(message);

        // Log message
        this.app.logger.log(`Message sent to ${recipient}`);

        // Trigger UI update
        this.updateMessageUI();

        return message;
    }

    // Retrieve messages for a specific conversation
    getConversation(participant) {
        return this.conversations.get(participant) || [];
    }

    // Mark messages as read
    markMessagesAsRead(participant) {
        const conversation = this.conversations.get(participant) || [];
        conversation.forEach(message => {
            if (message.recipient === this.app.state.messaging.authenticatedUser.username) {
                message.read = true;
            }
        });

        this.updateMessageUI();
    }

    // Generate unique message ID
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    // Update message-related UI
    updateMessageUI() {
        // Placeholder for UI update logic
        // In actual implementation, this would update conversation lists, 
        // unread message counts, etc.
        this.app.logger.log('Updated messaging UI');
    }

    // Get unread message count
    getUnreadMessageCount() {
        return this.app.state.messaging.messages.filter(
            msg => !msg.read && 
            msg.recipient === this.app.state.messaging.authenticatedUser.username
        ).length;
    }

    // Search messages
    searchMessages(query) {
        return this.app.state.messaging.messages.filter(message => 
            message.content.toLowerCase().includes(query.toLowerCase()) ||
            message.sender.toLowerCase().includes(query.toLowerCase()) ||
            message.recipient.toLowerCase().includes(query.toLowerCase())
        );
    }
}

// Extend the main application with these systems
MUNSpeechTimerApp.prototype.authManager = function() {
    return new AuthenticationManager(this);
};

MUNSpeechTimerApp.prototype.messagingSystem = function() {
    return new MessagingSystem(this);
};

// Add methods to the main application class
MUNSpeechTimerApp.prototype.updateUIAfterAuthentication = function() {
    // Enable messaging tab
    // Update user display
    // Potentially fetch initial messages
    this.logger.log('UI updated after authentication');
};

MUNSpeechTimerApp.prototype.updateUIAfterLogout = function() {
    // Disable messaging tab
    // Clear user information
    // Reset messaging-related UI
    this.logger.log('UI updated after logout');
};
// Role Call and Attendance Tracking System
class RoleCallManager {
    constructor(app) {
        this.app = app;
        
        // Attendance tracking configuration
        this.config = {
            maxHistoricalDates: 30, // Keep track of last 30 attendance dates
            defaultAttendanceStatus: false // Default to absent
        };
    }

    // Initialize attendance tracking for a committee
    initializeAttendanceTracking(committee) {
        const countries = this.app.state.committees[committee] || [];
        
        // Ensure attendance data structure exists
        if (!this.app.state.attendanceData[committee]) {
            this.app.state.attendanceData[committee] = {};
        }

        // Populate attendance data for each country
        countries.forEach(country => {
            if (!this.app.state.attendanceData[committee][country]) {
                this.app.state.attendanceData[committee][country] = {};
            }
        });

        this.app.logger.log(`Initialized attendance tracking for ${committee}`);
    }

    // Conduct role call for a specific date
    conductRoleCall(date = null) {
        const currentCommittee = this.app.state.currentCommittee;
        const targetDate = date || this.getCurrentDate();

        // Ensure attendance tracking is initialized
        this.initializeAttendanceTracking(currentCommittee);

        // Add date to historical dates if not exists
        if (!this.app.state.attendanceDates.includes(targetDate)) {
            this.app.state.attendanceDates.push(targetDate);
            
            // Trim historical dates if exceeding max
            if (this.app.state.attendanceDates.length > this.config.maxHistoricalDates) {
                this.app.state.attendanceDates.shift();
            }
        }

        // Prepare role call data
        const roleCallData = {
            date: targetDate,
            committee: currentCommittee,
            attendance: {}
        };

        // Get countries for current committee
        const countries = this.app.state.committees[currentCommittee] || [];

        // Initialize attendance for each country
        countries.forEach(country => {
            // Default to not present
            roleCallData.attendance[country] = this.config.defaultAttendanceStatus;
        });

        this.app.logger.log(`Conducted role call for ${targetDate}`);
        return roleCallData;
    }

    // Update attendance for a specific country
    updateAttendance(country, date, status) {
        const currentCommittee = this.app.state.currentCommittee;

        // Ensure attendance data structure exists
        if (!this.app.state.attendanceData[currentCommittee]) {
            this.app.state.attendanceData[currentCommittee] = {};
        }

        if (!this.app.state.attendanceData[currentCommittee][country]) {
            this.app.state.attendanceData[currentCommittee][country] = {};
        }

        // Update attendance status
        this.app.state.attendanceData[currentCommittee][country][date] = status;

        this.app.logger.log(`Updated attendance for ${country} on ${date}: ${status}`);
    }

    // Get attendance summary
    getAttendanceSummary(committee = null) {
        const targetCommittee = committee || this.app.state.currentCommittee;
        const attendanceData = this.app.state.attendanceData[targetCommittee] || {};

        const summary = {
            totalCountries: Object.keys(attendanceData).length,
            presentCountries: 0,
            attendanceRates: {}
        };

        // Calculate attendance rates
        Object.entries(attendanceData).forEach(([country, dateAttendance]) => {
            const presentDates = Object.entries(dateAttendance)
                .filter(([date, status]) => status === true)
                .map(([date]) => date);

            const attendanceRate = presentDates.length / this.app.state.attendanceDates.length;

            summary.attendanceRates[country] = {
                presentDates: presentDates,
                attendanceRate: attendanceRate
            };

            // Count present countries
            if (presentDates.length > 0) {
                summary.presentCountries++;
            }
        });

        this.app.logger.log(`Generated attendance summary for ${targetCommittee}`);
        return summary;
    }

    // Export attendance data
    exportAttendanceData(format = 'json') {
        const exportData = {
            committee: this.app.state.currentCommittee,
            dates: this.app.state.attendanceDates,
            attendanceData: this.app.state.attendanceData[this.app.state.currentCommittee]
        };

        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(exportData, null, 2);
            case 'csv':
                return this.convertToCSV(exportData);
            default:
                throw new Error('Unsupported export format');
        }
    }

    // Convert attendance data to CSV
    convertToCSV(exportData) {
        const headers = ['Country', ...exportData.dates];
        const csvRows = [headers.join(',')];

        Object.entries(exportData.attendanceData).forEach(([country, dateAttendance]) => {
            const row = [
                country,
                ...exportData.dates.map(date => 
                    dateAttendance[date] ? 'Present' : 'Absent'
                )
            ];
            csvRows.push(row.join(','));
        });

        return csvRows.join('\n');
    }

    // Get current date in YYYY-MM-DD format
    getCurrentDate() {
        return new Date().toISOString().split('T')[0];
    }

    // Lock countries for the current committee
    lockCountries() {
        const currentCommittee = this.app.state.currentCommittee;
        
        // Toggle lock status
        this.app.state.ui.isCountryListLocked = !this.app.state.ui.isCountryListLocked;

        this.app.logger.log(`Countries ${this.app.state.ui.isCountryListLocked ? 'locked' : 'unlocked'} for ${currentCommittee}`);
    }
}

// Utility Classes
class ReportGenerator {
    constructor(app) {
        this.app = app;
    }

    // Generate comprehensive session report
    generateSessionReport() {
        const report = {
            committee: this.app.state.currentCommittee,
            timestamp: new Date().toISOString(),
            speakerStats: this.generateSpeakerStatistics(),
            attendanceSummary: this.app.roleCallManager().getAttendanceSummary(),
            timerSummary: this.generateTimerSummary()
        };

        this.app.logger.log('Generated comprehensive session report');
        return report;
    }

    // Generate speaker statistics
    generateSpeakerStatistics() {
        const delegateData = this.app.state.delegateData;
        const speakerStats = {};

        Object.entries(delegateData).forEach(([speaker, data]) => {
            speakerStats[speaker] = {
                totalSpeeches: data.speeches.length,
                totalSpeakingTime: data.totalSpeakingTime,
                averageSpeechDuration: data.totalSpeakingTime / data.speeches.length || 0
            };
        });

        return speakerStats;
    }

    // Generate timer summary
    generateTimerSummary() {
        const timerSummary = {};
        
        Object.entries(this.app.state.timers).forEach(([timerType, timerData]) => {
            timerSummary[timerType] = {
                totalTime: timerData.elapsedTime / 1000, // Convert to seconds
                wasRunning: timerData.running
            };
        });

        return timerSummary;
    }

    // Export report to various formats
    exportReport(format = 'json') {
        const report = this.generateSessionReport();

        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(report, null, 2);
            case 'text':
                return this.convertReportToText(report);
            default:
                throw new Error('Unsupported export format');
        }
    }

    // Convert report to human-readable text
    convertReportToText(report) {
        let reportText = `Session Report for ${report.committee}\n`;
        reportText += `Generated: ${report.timestamp}\n\n`;

        // Speaker Statistics
        reportText += "Speaker Statistics:\n";
        Object.entries(report.speakerStats).forEach(([speaker, stats]) => {
            reportText += `${speaker}:\n`;
            reportText += `  Total Speeches: ${stats.totalSpeeches}\n`;
            reportText += `  Total Speaking Time: ${stats.totalSpeakingTime.toFixed(2)} seconds\n`;
            reportText += `  Average Speech Duration: ${stats.averageSpeechDuration.toFixed(2)} seconds\n\n`;
        });

        // Attendance Summary
        reportText += "Attendance Summary:\n";
        reportText += `Total Countries: ${report.attendanceSummary.totalCountries}\n`;
        reportText += `Present Countries: ${report.attendanceSummary.presentCountries}\n\n`;

        // Timer Summary
        reportText += "Timer Summary:\n";
        Object.entries(report.timerSummary).forEach(([timerType, timerStats]) => {
            reportText += `${timerType} Timer:\n`;
            reportText += `  Total Time: ${timerStats.totalTime.toFixed(2)} seconds\n`;
            reportText += `  Was Running: ${timerStats.wasRunning}\n\n`;
        });

        return reportText;
    }
}

// Extend the main application with these managers
MUNSpeechTimerApp.prototype.roleCallManager = function() {
    return new RoleCallManager(this);
};

MUNSpeechTimerApp.prototype.reportGenerator = function() {
    return new ReportGenerator(this);
};
// UI Management and Event Handling System
class UIManager {
    constructor(app) {
        this.app = app;
        
        // UI Configuration
        this.config = {
            themes: {
                default: {
                    primary: '#6750A4',
                    secondary: '#625B71',
                    background: '#F8F8FC',
                    text: '#1C1B1F'
                },
                dark: {
                    primary: '#BB86FC',
                    secondary: '#03DAC6',
                    background: '#121212',
                    text: '#FFFFFF'
                }
            },
            tabs: [
                { id: 'main', label: 'Main Dashboard', icon: 'dashboard' },
                { id: 'speaking-list', label: 'Speaking List', icon: 'list' },
                { id: 'messaging', label: 'Messaging', icon: 'message' }
            ]
        };

        // DOM Element References
        this.elements = {
            root: null,
            tabs: {},
            tabContents: {},
            committeeSelect: null,
            countryList: null,
            speakingList: null,
            timers: {},
            buttons: {}
        };

        // Event Listeners Registry
        this.eventListeners = new Map();
    }

    // Initialize UI
    initialize() {
        this.cacheElements();
        this.setupTabs();
        this.setupEventListeners();
        this.applyTheme();
        this.updateUIState();
    }

    // Cache DOM Elements
    cacheElements() {
        // Dynamically cache elements based on configuration
        this.elements.root = document.getElementById('app');
        
        // Tab elements
        this.config.tabs.forEach(tab => {
            this.elements.tabs[tab.id] = document.querySelector(`.tab[data-tab="${tab.id}"]`);
            this.elements.tabContents[tab.id] = document.getElementById(`${tab.id}-tab`);
        });

        // Committee and list elements
        this.elements.committeeSelect = document.getElementById('committee-select');
        this.elements.countryList = document.getElementById('country-list');
        this.elements.speakingList = document.getElementById('speaking-list');

        // Timer elements
        ['session', 'caucus', 'speech'].forEach(timerType => {
            this.elements.timers[timerType] = {
                display: document.getElementById(`${timerType}-timer`),
                startBtn: document.querySelector(`[data-timer="${timerType}"][data-action="start"]`),
                stopBtn: document.querySelector(`[data-timer="${timerType}"][data-action="stop"]`),
                resetBtn: document.querySelector(`[data-timer="${timerType}"][data-action="reset"]`)
            };
        });

        // Common buttons
        this.elements.buttons = {
            addToList: document.getElementById('add-to-list-button'),
            nextSpeaker: document.getElementById('next-speaker-button'),
            skipSpeaker: document.getElementById('skip-speaker-button'),
            exportData: document.getElementById('export-button'),
            roleCall: document.getElementById('role-call-button'),
            lockCountries: document.getElementById('lock-countries-button')
        };
    }

    // Setup Tab System
    setupTabs() {
        this.config.tabs.forEach(tab => {
            const tabElement = this.elements.tabs[tab.id];
            const tabContent = this.elements.tabContents[tab.id];

            if (tabElement && tabContent) {
                tabElement.addEventListener('click', () => {
                    this.switchTab(tab.id);
                });
            }
        });
    }

    // Switch Active Tab
    switchTab(tabId) {
        // Remove active class from all tabs and tab contents
        this.config.tabs.forEach(tab => {
            this.elements.tabs[tab.id].classList.remove('active');
            this.elements.tabContents[tab.id].classList.remove('active');
        });

        // Add active class to selected tab
        this.elements.tabs[tabId].classList.add('active');
        this.elements.tabContents[tabId].classList.add('active');

        // Log tab switch
        this.app.logger.log(`Switched to ${tabId} tab`);

        // Trigger any tab-specific initialization
        this.updateUIState(tabId);
    }

    // Setup Event Listeners
    setupEventListeners() {
        // Committee Selection
        if (this.elements.committeeSelect) {
            this.elements.committeeSelect.addEventListener('change', () => {
                this.handleCommitteeChange();
            });
        }

        // Country List Interactions
        if (this.elements.countryList) {
            this.elements.countryList.addEventListener('click', (event) => {
                this.handleCountrySelection(event);
            });
        }

        // Speaking List Interactions
        if (this.elements.speakingList) {
            this.elements.speakingList.addEventListener('click', (event) => {
                this.handleSpeakerSelection(event);
            });
        }

        // Button Event Listeners
        Object.entries(this.elements.buttons).forEach(([key, button]) => {
            if (button) {
                button.addEventListener('click', () => this.handleButtonClick(key));
            }
        });

        // Timer Button Listeners
        Object.values(this.elements.timers).forEach(timer => {
            ['startBtn', 'stopBtn', 'resetBtn'].forEach(btnType => {
                if (timer[btnType]) {
                    timer[btnType].addEventListener('click', () => {
                        this.handleTimerAction(
                            timer[btnType].getAttribute('data-timer'),
                            timer[btnType].getAttribute('data-action')
                        );
                    });
                }
            });
        });
    }

    // Handle Committee Change
    handleCommitteeChange() {
        const selectedCommittee = this.elements.committeeSelect.value;
        this.app.state.currentCommittee = selectedCommittee;
        
        // Update country list
        this.updateCountryList();
        
        // Log committee change
        this.app.logger.log(`Changed committee to ${selectedCommittee}`);
    }

    // Update Country List
    updateCountryList() {
        const committee = this.app.state.currentCommittee;
        const countries = this.app.state.committees[committee] || [];

        // Clear existing list
        this.elements.countryList.innerHTML = '';

        // Populate country list
        countries.forEach(country => {
            const li = document.createElement('li');
            li.textContent = country;
            li.classList.add('list-item');
            this.elements.countryList.appendChild(li);
        });
    }

    // Handle Country Selection
    handleCountrySelection(event) {
        if (event.target.classList.contains('list-item')) {
            // Remove previous selections
            this.elements.countryList.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Select clicked country
            event.target.classList.add('selected');
            this.app.state.ui.selectedCountry = event.target.textContent;
        }
    }

    // Handle Speaker Selection
    handleSpeakerSelection(event) {
        if (event.target.classList.contains('list-item')) {
            // Remove previous selections
            this.elements.speakingList.querySelectorAll('.list-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Select clicked speaker
            event.target.classList.add('selected');
        }
    }

    // Handle Button Clicks
    handleButtonClick(buttonKey) {
        switch(buttonKey) {
            case 'addToList':
                this.addToSpeakingList();
                break;
            case 'nextSpeaker':
                this.app.speakingListManager().nextSpeaker();
                break;
            case 'skipSpeaker':
                this.app.speakingListManager().skipCurrentSpeaker();
                break;
            case 'exportData':
                this.exportSessionData();
                break;
            case 'roleCall':
                this.openRoleCallModal();
                break;
            case 'lockCountries':
                this.app.roleCallManager().lockCountries();
                break;
            default:
                this.app.logger.log(`Unhandled button click: ${buttonKey}`);
        }
    }

    // Add Country to Speaking List
    addToSpeakingList() {
        const selectedCountry = this.app.state.ui.selectedCountry;
        if (selectedCountry) {
            this.app.speakingListManager().addToSpeakingList(selectedCountry);
        } else {
            this.showMessage('Selection Required', 'Please select a country first');
        }
    }

    // Handle Timer Actions
    handleTimerAction(timerType, action) {
        const timerManager = this.app.timerManager();
        
        switch(action) {
            case 'start':
                timerManager.startTimer(timerType);
                break;
            case 'stop':
                timerManager.stopTimer(timerType);
                break;
            case 'reset':
                timerManager.resetTimer(timerType);
                break;
        }
    }

    // Export Session Data
    exportSessionData() {
        try {
            const reportGenerator = this.app.reportGenerator();
            const exportedData = reportGenerator.exportReport('json');
            
            // Create download link
            const blob = new Blob([exportedData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mun_session_report_${new Date().toISOString().split('T')[0]}.json`;
            a.click();

            this.app.logger.log('Session data exported');
        } catch (error) {
            this.showMessage('Export Error', error.message);
        }
    }

    // Open Role Call Modal
    openRoleCallModal() {
        // Placeholder for role call modal logic
        const roleCallModal = document.getElementById('role-call-modal');
        if (roleCallModal) {
            roleCallModal.style.display = 'flex';
        }
    }

    // Update UI State
    updateUIState(activeTab = 'main') {
        // Manage UI state based on current context
        switch(activeTab) {
            case 'main':
                this.updateMainDashboard();
                break;
            case 'speaking-list':
                this.updateSpeakingListView();
                break;
            case 'messaging':
                this.updateMessagingView();
                break;
        }
    }

    // Update Main Dashboard
    updateMainDashboard() {
        // Update committee select
        this.elements.committeeSelect.value = this.app.state.currentCommittee;
        
        // Update country list
        this.updateCountryList();
    }

    // Update Speaking List View
    updateSpeakingListView() {
        // Clear existing list
        this.elements.speakingList.innerHTML = '';

        // Populate speaking list
        this.app.state.speakingList.forEach(speaker => {
            const li = document.createElement('li');
            li.textContent = speaker;
            li.classList.add('list-item');
            this.elements.speakingList.appendChild(li);
        });
    }

    // Update Messaging View
    updateMessagingView() {
        // Placeholder for messaging view update
        // Would include populating conversation list, etc.
    }

    // Apply Theme
    applyTheme(themeName = 'default') {
        const theme = this.config.themes[themeName];
        
        if (theme) {
            Object.entries(theme).forEach(([key, value]) => {
                document.documentElement.style.setProperty(`--${key}`, value);
            });
        }
    }

    // Show Message (Simple Modal/Alert)
    showMessage(title, message, type = 'info') {
        // In a real implementation, this would be a more sophisticated modal
        alert(`${title}: ${message}`);
        this.app.logger.log(`${type.toUpperCase()} Message: ${title} - ${message}`);
    }
}

// Extend the main application with UI Manager
MUNSpeechTimerApp.prototype.uiManager = function() {
    return new UIManager(this);
};

// Initialize UI when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Assuming the main app instance is already created
    if (window.munApp) {
        const uiManager = window.munApp.uiManager();
        uiManager.initialize();
    }
});
// Advanced Utilities and System Integration
class SystemIntegrationManager {
    constructor(app) {
        this.app = app;
        
        // Configuration for external integrations
        this.config = {
            backupServices: [
                { 
                    name: 'localStorage', 
                    priority: 1 
                },
                { 
                    name: 'cloudStorage', 
                    priority: 2 
                }
            ],
            supportedExportFormats: ['json', 'csv', 'xlsx'],
            cloudSyncInterval: 5 * 60 * 1000 // 5 minutes
        };

        // Error tracking and reporting
        this.errorTracker = {
            errors: [],
            maxErrorLog: 100,
            critical: []
        };

        // Performance monitoring
        this.performanceMonitor = {
            markers: new Map(),
            measurements: []
        };
    }

    // Comprehensive Error Handling System
    class ErrorHandler {
        constructor(integrationManager) {
            this.manager = integrationManager;
            this.errorTypes = {
                NETWORK: 'network',
                AUTHENTICATION: 'auth',
                DATA_VALIDATION: 'validation',
                SYSTEM: 'system',
                UNKNOWN: 'unknown'
            };
        }

        // Classify and handle errors
        handle(error, context = {}) {
            const errorEntry = {
                id: this.generateErrorId(),
                timestamp: new Date(),
                message: error.message,
                stack: error.stack,
                type: this.classifyError(error),
                context: context
            };

            // Log error
            this.log(errorEntry);

            // Determine severity and take action
            this.processError(errorEntry);

            return errorEntry;
        }

        // Generate unique error identifier
        generateErrorId() {
            return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // Classify error type
        classifyError(error) {
            // Implement sophisticated error classification
            if (error.name === 'NetworkError') return this.errorTypes.NETWORK;
            if (error.name === 'AuthenticationError') return this.errorTypes.AUTHENTICATION;
            if (error.name === 'ValidationError') return this.errorTypes.DATA_VALIDATION;
            
            return this.errorTypes.UNKNOWN;
        }

        // Log error
        log(errorEntry) {
            const manager = this.manager;
            
            // Add to error tracker
            manager.errorTracker.errors.push(errorEntry);

            // Trim error log if exceeds max
            if (manager.errorTracker.errors.length > manager.errorTracker.maxErrorLog) {
                manager.errorTracker.errors.shift();
            }

            // Log to console
            console.error('Application Error:', errorEntry);

            // Track critical errors
            if (this.isCritical(errorEntry)) {
                manager.errorTracker.critical.push(errorEntry);
                this.notifyAdministrator(errorEntry);
            }
        }

        // Determine if error is critical
        isCritical(errorEntry) {
            const criticalTypes = [
                this.errorTypes.AUTHENTICATION,
                this.errorTypes.NETWORK,
                this.errorTypes.SYSTEM
            ];

            return criticalTypes.includes(errorEntry.type);
        }

        // Notify system administrator
        notifyAdministrator(errorEntry) {
            // In a real implementation, this would send an email or trigger an alert
            console.warn('Critical Error - Administrator Notification', errorEntry);
        }
    }

    // Performance Monitoring Utility
    performanceMonitoring() {
        return {
            // Start tracking a performance marker
            mark(name) {
                performance.mark(`${name}-start`);
            },

            // End tracking and measure performance
            measure(name) {
                performance.mark(`${name}-end`);
                performance.measure(name, `${name}-start`, `${name}-end`);

                // Get the last measurement
                const entries = performance.getEntriesByName(name);
                const lastEntry = entries[entries.length - 1];

                return {
                    name: name,
                    duration: lastEntry.duration,
                    startTime: lastEntry.startTime
                };
            },

            // Get all performance measurements
            getAllMeasurements() {
                return performance.getEntries()
                    .filter(entry => entry.entryType === 'measure')
                    .map(entry => ({
                        name: entry.name,
                        duration: entry.duration,
                        startTime: entry.startTime
                    }));
            },

            // Clear all performance entries
            clear() {
                performance.clearMarks();
                performance.clearMeasures();
            }
        };
    }

    // Backup and Synchronization
    backupManager() {
        return {
            // Backup application state
            backup(format = 'json') {
                const state = this.app.state;
                
                switch (format.toLowerCase()) {
                    case 'json':
                        return JSON.stringify(state, null, 2);
                    case 'csv':
                        return this.convertToCSV(state);
                    default:
                        throw new Error(`Unsupported backup format: ${format}`);
                }
            },

            // Restore application state
            restore(backupData, format = 'json') {
                try {
                    let parsedData;
                    
                    switch (format.toLowerCase()) {
                        case 'json':
                            parsedData = JSON.parse(backupData);
                            break;
                        case 'csv':
                            parsedData = this.parseCSV(backupData);
                            break;
                        default:
                            throw new Error(`Unsupported restore format: ${format}`);
                    }

                    // Merge restored data
                    this.app.state = {
                        ...this.app.state,
                        ...parsedData
                    };

                    this.app.logger.log('State restored successfully');
                    return true;
                } catch (error) {
                    this.app.logger.error(`State restoration failed: ${error.message}`);
                    return false;
                }
            },

            // Convert state to CSV
            convertToCSV(state) {
                // Implement CSV conversion logic
                // This is a simplified example
                return Object.entries(state)
                    .map(([key, value]) => `${key},${JSON.stringify(value)}`)
                    .join('\n');
            },

            // Parse CSV backup
            parseCSV(csvData) {
                return Object.fromEntries(
                    csvData.split('\n')
                        .map(line => {
                            const [key, value] = line.split(',');
                            return [key, JSON.parse(value)];
                        })
                );
            }
        };
    }

    // Cloud Synchronization
    cloudSyncManager() {
        return {
            // Simulate cloud synchronization
            sync() {
                try {
                    // In a real implementation, this would sync with a cloud service
                    const stateToSync = this.app.state;
                    
                    // Simulated cloud sync
                    console.log('Syncing state to cloud', stateToSync);

                    return {
                        success: true,
                        timestamp: new Date()
                    };
                } catch (error) {
                    console.error('Cloud sync failed', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            },

            // Start periodic synchronization
            startPeriodicSync() {
                return setInterval(() => {
                    this.sync();
                }, this.config.cloudSyncInterval);
            }
        };
    }

    // Diagnostic and Troubleshooting Utilities
    diagnosticTools() {
        return {
            // Generate comprehensive system report
            generateSystemReport() {
                return {
                    appVersion: this.app.config.version,
                    timestamp: new Date(),
                    state: {
                        currentCommittee: this.app.state.currentCommittee,
                        speakingListLength: this.app.state.speakingList.length,
                        timers: Object.keys(this.app.state.timers)
                            .map(timerType => ({
                                type: timerType,
                                running: this.app.state.timers[timerType].running,
                                elapsedTime: this.app.state.timers[timerType].elapsedTime
                            }))
                    },
                    errors: this.errorTracker.errors.slice(-10), // Last 10 errors
                    performanceMeasurements: this.performanceMonitor.measurements.slice(-10) // Last 10 performance measurements
                };
            },

            // Run system self-check
            selfCheck() {
                const report = this.generateSystemReport();
                
                const checks = {
                    stateIntegrity: this.checkStateIntegrity(),
                    performanceHealth: this.checkPerformanceHealth(),
                    errorStatus: this.checkErrorStatus()
                };

                return {
                    ...report,
                    systemChecks: checks
                };
            },

            // Check state integrity
            checkStateIntegrity() {
                // Implement state validation logic
                const state = this.app.state;
                const issues = [];

                if (!state.currentCommittee) {
                    issues.push('No current committee selected');
                }

                return {
                    healthy: issues.length === 0,
                    issues: issues
                };
            },

            // Check performance health
            checkPerformanceHealth() {
                const measurements = this.performanceMonitor.measurements;
                
                // Calculate average performance
                const avgDuration = measurements.length > 0 
                    ? measurements.reduce((sum, m) => sum + m.duration, 0) / measurements.length
                    : 0;

                return {
                    averagePerformance: avgDuration,
                    healthy: avgDuration < 100 // milliseconds threshold
                };
            },

            // Check error status
            checkErrorStatus() {
                const errors = this.errorTracker.errors;
                
                return {
                    totalErrors: errors.length,
                    criticalErrors: this.errorTracker.critical.length,
                    healthy: this.errorTracker.critical.length === 0
                };
            }
        };
    }
}

// Extend the main application with System Integration Manager
MUNSpeechTimerApp.prototype.systemIntegration = function() {
    return new SystemIntegrationManager(this);
};

// Export error handling as a global utility
window.MUNErrorHandler = SystemIntegrationManager.ErrorHandler;

// Initialize system integration when app starts
document.addEventListener('DOMContentLoaded', () => {
    if (window.munApp) {
        const systemIntegration = window.munApp.systemIntegration();
        
        // Setup error handling
        window.addEventListener('error', (event) => {
            const errorHandler = new SystemIntegrationManager.ErrorHandler(systemIntegration);
            errorHandler.handle(event.error, {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });

        // Setup performance monitoring
        const performanceMonitor = systemIntegration.performanceMonitoring();
        performanceMonitor.mark('appInitialization');
    }
});
class TimerManager {
    constructor(app) {
        this.app = app;
    }

    // Start a specific timer
    startTimer(timerType) {
        const timer = this.app.state.timers[timerType];
        
        if (!timer.running) {
            timer.running = true;
            timer.startTime = Date.now();
            
            // Update timer display periodically
            timer.intervalId = setInterval(() => {
                timer.elapsedTime = Date.now() - timer.startTime;
                this.updateTimerDisplay(timerType);
            }, 1000);

            this.app.logger.log(`${timerType} timer started`);
        }
    }

    // Stop a specific timer
    stopTimer(timerType) {
        const timer = this.app.state.timers[timerType];
        
        if (timer.running) {
            timer.running = false;
            timer.elapsedTime = Date.now() - timer.startTime;
            
            // Clear the interval
            if (timer.intervalId) {
                clearInterval(timer.intervalId);
                timer.intervalId = null;
            }

            this.updateTimerDisplay(timerType);
            this.app.logger.log(`${timerType} timer stopped`);
        }
    }

    // Reset a specific timer
    resetTimer(timerType) {
        const timer = this.app.state.timers[timerType];
        
        // Stop timer if running
        if (timer.running) {
            this.stopTimer(timerType);
        }

        // Reset timer properties
        timer.elapsedTime = 0;
        timer.startTime = null;
        
        this.updateTimerDisplay(timerType);
        this.app.logger.log(`${timerType} timer reset`);
    }

    // Update timer display in the UI
    updateTimerDisplay(timerType) {
        const timer = this.app.state.timers[timerType];
        const timerElement = document.getElementById(`${timerType}-timer`);
        
        if (timerElement) {
            // Convert milliseconds to seconds
            const seconds = Math.floor(timer.elapsedTime / 1000);
            timerElement.textContent = this.app.formatTime(seconds);
        }
    }

class CountryListManager {
    constructor(app) {
        this.app = app;
    }

    // Populate country list for current committee
    populateCountryList() {
        const currentCommittee = this.app.state.currentCommittee;
        const countryListElement = document.getElementById('country-list');
        
        if (!countryListElement) return;

        // Clear existing list
        countryListElement.innerHTML = '';

        // Get countries for current committee
        const countries = this.app.state.committees[currentCommittee] || [];

        // Populate list
        countries.forEach(country => {
            const listItem = document.createElement('li');
            listItem.textContent = country;
            listItem.classList.add('list-item');
            listItem.setAttribute('data-country', country);
            
            // Add click event listener for selection
            listItem.addEventListener('click', () => {
                // Remove previous selections
                countryListElement.querySelectorAll('.list-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Select current item
                listItem.classList.add('selected');
                this.app.state.ui.selectedCountry = country;
            });

            countryListElement.appendChild(listItem);
        });

        this.app.logger.log(`Populated country list for ${currentCommittee}`);
    }

    // Update country list when committee changes
    setupCommitteeChangeListener() {
        const committeeSelect = document.getElementById('committee-select');
        
        if (committeeSelect) {
            committeeSelect.addEventListener('change', (event) => {
                // Update current committee in state
                this.app.state.currentCommittee = event.target.value;
                
                // Repopulate country list
                this.populateCountryList();
            });
        }
    }
}

// Extend the main application with new managers
MUNSpeechTimerApp.prototype.timerManager = function() {
    return new TimerManager(this);
};

// Add initialization method to extend authentication functionality
MUNSpeechTimerApp.prototype.initializeAuthentication = function() {
    // Check for existing authentication
    const authManager = this.authManager();
    if (authManager.checkExistingAuthentication()) {
        // Potentially refresh or validate existing token
        this.updateUIAfterAuthentication();
    }

    // Setup login button
    const loginButton = document.getElementById('login-button');
    if (loginButton) {
        loginButton.addEventListener('click', () => {
            authManager.initiateGitHubAuth();
        });
    }

    // Handle OAuth callback if on callback page
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const state = urlParams.get('state');

    if (code && state) {
        authManager.handleOAuthCallback(code, state);
    }
};

// Modify initialization to include new managers
MUNSpeechTimerApp.prototype.initializeApplication = function() {
    try {
        this.loadPersistedState();
        this.setupEventListeners();
        
        // Initialize UI and managers
        const uiManager = this.uiManager();
        uiManager.initialize();

        // Initialize country list manager
        const countryListManager = new CountryListManager(this);
        countryListManager.populateCountryList();
        countryListManager.setupCommitteeChangeListener();

        // Initialize authentication
        this.initializeAuthentication();

        // Start analytics session
        this.analytics.startSession();
        this.logger.log('Application initialized successfully');
    } catch (error) {
        this.logger.error(`Initialization failed: ${error.message}`);
        this.displayErrorToUser(error);
    }
};

// Modify application initialization to add timer functionality
document.addEventListener('DOMContentLoaded', () => {
    window.munApp = new MUNSpeechTimerApp();

    // Setup timer buttons
    ['session', 'caucus', 'speech'].forEach(timerType => {
        const startBtn = document.querySelector(`[data-timer="${timerType}"][data-action="start"]`);
        const stopBtn = document.querySelector(`[data-timer="${timerType}"][data-action="stop"]`);
        const resetBtn = document.querySelector(`[data-timer="${timerType}"][data-action="reset"]`);

        if (startBtn) startBtn.addEventListener('click', () => window.munApp.timerManager().startTimer(timerType));
        if (stopBtn) stopBtn.addEventListener('click', () => window.munApp.timerManager().stopTimer(timerType));
        if (resetBtn) resetBtn.addEventListener('click', () => window.munApp.timerManager().resetTimer(timerType));
    });
});
